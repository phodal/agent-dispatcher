package com.github.phodal.acpmanager.dispatcher.model

import kotlinx.serialization.Serializable

/**
 * Represents a task generated by the Master Agent's plan.
 */
@Serializable
data class AgentTask(
    val id: String,
    val title: String,
    val description: String,
    val assignedAgent: String? = null,
    val status: AgentTaskStatus = AgentTaskStatus.QUEUED,
    val dependencies: List<String> = emptyList(),
    val parallelGroup: Int? = null,
    val progress: Int = 0,
    /** Summary of this task's output, used as context for dependent tasks. */
    val result: String? = null,
) {
    fun isTerminal(): Boolean =
        status == AgentTaskStatus.DONE || status == AgentTaskStatus.FAILED || status == AgentTaskStatus.BLOCKED
}

/**
 * Task status in the dispatcher lifecycle.
 */
@Serializable
enum class AgentTaskStatus {
    QUEUED,
    ACTIVE,
    RUNNING,
    BLOCKED,
    DONE,
    FAILED,
}

/**
 * Execution strategy for the plan.
 *
 * - MULTI_AGENT: Each task can be dispatched to a different agent. Best for independent/parallel work.
 * - SINGLE_AGENT: All tasks use the same agent, preserving conversational context.
 *   Best for sequential tasks that build on each other.
 */
@Serializable
enum class ExecutionStrategy {
    MULTI_AGENT,
    SINGLE_AGENT,
}

/**
 * The overall plan produced by the Master Agent.
 */
@Serializable
data class DispatchPlan(
    val tasks: List<AgentTask>,
    val maxParallelism: Int = 1,
    val thinking: String = "",
    /** Whether to use multi-agent or single-agent execution. */
    val strategy: ExecutionStrategy = ExecutionStrategy.MULTI_AGENT,
) {
    val totalTasks: Int get() = tasks.size
    val completedTasks: Int get() = tasks.count { it.status == AgentTaskStatus.DONE }
    val activeTasks: Int get() = tasks.count { it.status == AgentTaskStatus.RUNNING || it.status == AgentTaskStatus.ACTIVE }
}

/**
 * An agent role that can be assigned to tasks.
 */
@Serializable
data class AgentRole(
    val id: String,
    val name: String,
    val acpAgentKey: String,
    val model: String = "",
    val color: String = "",
)

/**
 * A log entry from an agent execution.
 */
data class AgentLogEntry(
    val timestamp: Long = System.currentTimeMillis(),
    val level: LogLevel,
    val source: String,
    val taskId: String? = null,
    val message: String,
)

enum class LogLevel {
    INF, WRN, ERR, DBG
}

/**
 * State of the entire multi-agent dispatcher.
 */
data class DispatcherState(
    val status: DispatcherStatus = DispatcherStatus.IDLE,
    val plan: DispatchPlan? = null,
    val agents: List<AgentRole> = emptyList(),
    val activeAgentCount: Int = 0,
    val totalAgentCount: Int = 0,
    val logs: List<AgentLogEntry> = emptyList(),
    val masterAgentKey: String? = null,
    val error: String? = null,
)

enum class DispatcherStatus {
    IDLE,
    PLANNING,
    PLANNED,
    RUNNING,
    PAUSED,
    COMPLETED,
    FAILED,
}
